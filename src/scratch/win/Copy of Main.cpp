#include <stdio.h>
#include "../base_lib/CryptoHelper.h"
#include <string>
#include <stdlib.h>
#include <iostream> 

using namespace std;
namespace license {

void write_pubkey_file(string public_fname, BYTE *pbPublicKey,
		DWORD dwPublicKeySize) {
	FILE* fp = fopen(public_fname.c_str(), "w");
	fprintf(fp, "//file generated by bootstrap.cpp, do not edit.\n\n");
	fprintf(fp, "#ifndef PUBLIC_KEY_H_\n#define PUBLIC_KEY_H_\n");
	fprintf(fp, "static BYTE PUBLIC_KEY[] = {");
	for (int i = 0; i < dwPublicKeySize; i++) {
		if (i != 0) {
			fprintf(fp, ",");
		}
		if (i % 15 == 0) {
			fprintf(fp, "\n        ");
		}
		fprintf(fp, "%d", pbPublicKey[i]);
	}
	fprintf(fp, "\n};\n\n");
	int random = rand() % 1000;
	fprintf(fp, "#define SHARED_RANDOM %d;\n", random);
	fprintf(fp, "#endif\n");
	fclose(fp);
}

void write_privkey_file(string private_fname, BYTE *privateKey,
		DWORD dwPrivateKeySize) {
	FILE* fp = fopen(private_fname.c_str(), "w");
	fprintf(fp, "//file generated by bootstrap.cpp, do not edit.\n\n");
	fprintf(fp, "#ifndef PRIVATE_KEY_H_\n#define PRIVATE_KEY_H_\n");
	fprintf(fp, "static BYTE PRIVATE_KEY[] = {");
	for (int i = 0; i < dwPrivateKeySize; i++) {
		if (i != 0) {
			fprintf(fp, ",");
		}
		if (i % 15 == 0) {
			fprintf(fp, "\n        ");
		}
		fprintf(fp, "%d", privateKey[i]);
	}
	fprintf(fp, "\n};\n\n");
	fprintf(fp, "#endif\n");
	fclose(fp);
}

void generatePk(string private_include, string public_include) {
	unique_ptr<CryptoHelper> cryptoHlpr = CryptoHelper.getInstance();
	BYTE *pbPublicKey = NULL, *pbPrivateKey = NULL;
	DWORD dwPublicKeySize = 0, dwPrivateKeySize = 0;
	HRESULT hr = S_OK;
	// Get the key container context.
	if (FAILED(hr = cryptoHlpr.AcquireContext(_T("TestContainer")))) {
// Call FormatMessage to display the error returned in hr.
		return;
	}
	// Generate the public/private key pair.
	if (FAILED(hr = cryptoHlpr.GenerateKeyPair())) {
// Call FormatMessage to display the error returned in hr.
		return;
	}
	// Export out the public key blob.
	if (FAILED(
			hr = cryptoHlpr.ExportPublicKey(&pbPublicKey, dwPublicKeySize))) {
// Call FormatMessage to display the error returned in hr.
		cerr << "error exporting pubkey" << endl;
		return;
	} else {
		write_pubkey_file(public_include, pbPublicKey, dwPublicKeySize);
	}
	// Print out the public key to console as a
	// hexadecimal string.
	wprintf(L"\n\nPublicKey = \"");
	for (DWORD i = 0; i < dwPublicKeySize; i++) {
		wprintf(L"%02x", pbPublicKey[i]);
	}
	wprintf(L"\"\n");
	// Export out the private key blob.
	if (FAILED(cryptoHlpr.ExportPrivateKey(&pbPrivateKey, dwPrivateKeySize))) {
		cerr << "Error exporting private key." << endl;
		return;
	} else {
		write_privkey_file(private_include, pbPrivateKey, dwPrivateKeySize);
	}
	// Print out the private key to console as a
	// hexadecimal string.
	wprintf(L"\n\nPrivateKey = \"");
	for (DWORD i = 0; i < dwPrivateKeySize; i++) {
		wprintf(L"%02x", pbPrivateKey[i]);
	}
	wprintf(L"\"\n");
	// Delete the public key blob allocated by the
// ExportPublicKey method.
	if (pbPublicKey)
		delete[] pbPublicKey;
	// Delete the private key blob allocated by the
// ExportPrivateKey method.
	if (pbPrivateKey)
		delete[] pbPrivateKey;
	return;
}
}

int main(int argc, char** argv) {

	if (argc != 3) {
		//print_usage();
		exit(2);
	} else {
		printf("********************************************\n");
		printf("*  Bootstrap!!!                            *\n");
		printf("********************************************\n");

	}
	string private_fname = string(argv[1]);
	string public_fname(argv[2]);

	license::generatePk(private_fname, public_fname);
	return 0;
}
